/*
 * ws2812b.c
 * 
 * 
 * Stephan Baerwolf (matrixstorm@gmx.de), Schwansee 2020
 * (please contact me at least before commercial use)
 */

#define __WS2812B_C_735f31908ba311eaab120800200c9a66	1

#include "ws2812b.h"
#include "libraries/API/iocomfort.h"

#include <stdint.h>

#include <avr/pgmspace.h>
#include <avr/interrupt.h>

/* 2D structure: Every line corresponds to a databyte to be translate into NRZO-SPI bits    */
/*               The colums are the 24 spi-bits per databyte to be transmitted              */
/* In order to save cycles, we avoid loading registers whereever we can - so align properly */
/*                                                                                          */
/* Color value 0xff is an ESC sequence to send only SPI-zeros.                              */
/* Because in USART SPI TY is high by default, we need the 50us (min) low to reset WS2812B  */
/* This is achieved by sending 16byte of 0xff (16byte * 8bit * 0.4us --> 51.2us)            */

/*
 * // compile with "gcc gen.c -o gen" only on littleEndian
 * #include <stdlib.h>
 * #include <stdio.h>
 * 
 * #include <stdint.h>
 * 
 * static uint8_t __NRZIsequence[3][256];
 * 
 * int main(int argc, char **argv) {
 * int x,y;
 * 
 * //fill the array
 * for (x=0;x<256;x++) {
 * uint8_t i, tmp;
 * uint32_t nrzibits = 0;
 * 
 * //x is the data value to translate into nrzo
 * tmp=x;
 * for (i=0;i<8;i++) {
 * nrzibits<<=3;
 * if ((tmp & 1) != 0) nrzibits|=0b011; //1
 * else                nrzibits|=0b001; //0
 * tmp>>=1;
 * }
 * 
 * for (y=0;y<3;y++) {
 * __NRZIsequence[y][x]=nrzibits & 0xff;
 * nrzibits>>=8;
 * }
 * }
 * 
 * //output the array as C structure
 * for (y=0;y<3;y++) {
 * printf("t{");
 * for (x=0;x<256;x++) {
 * printf("0x%02x, ",__NRZIsequence[y][x]);
 * }
 * printf("},n");
 * }
 * return EXIT_SUCCESS;
 * }
 */
static const PROGMEM __attribute__ ((used,aligned(256))) uint8_t __NRZIsequence[3][256] = {
	{0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0x59, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0x00},
	{0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0xb2, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0x96, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6, 0x00},
	{0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x6d, 0x24, 0x64, 0x2c, 0x6c, 0x25, 0x65, 0x2d, 0x00}
};

static uint8_t __ws2812b_initialized = 0xff;
static uint8_t __ws2812b_baudrateval = ((F_CPU/1000)/5000)-1; /* we need a prescaler of 8 --> 2(3+1) --> datasheet page 205 "clock generation" */
EXTFUNC_void(int8_t, ws2812b_initialize) {
  if (__ws2812b_initialized != 0xff) return -1;

  UBRR0 = 0;

  SET_LOW(WS2812B_TXPin);
  CFG_OUTPUT(WS2812B_TXPin);
#ifdef WS2812B_CLKPin
  SET_LOW(WS2812B_CLKPin);
  CFG_OUTPUT(WS2812B_CLKPin);
#endif

  UCSR0C = _BV(UMSEL01)|_BV(UMSEL00)|_BV(UDORD0)|_BV(UCPHA0); /* setup LSB first on leading rising edge */
  __ws2812b_initialized = UCSR0B;
  //UCSR0B =  _BV(TXEN0)|_BV(TXCIE0);

  UBRR0 = __ws2812b_baudrateval;
  //UBRR0 = 4095;

  __register8=0;
  __register9=0;
  return 0;
}

EXTFUNC_void(int8_t, ws2812b_finalize) {
  return 0;
}



ISR(WS2812B_TXComplete_vect) {
  __register8=0;
  __register9=0;
  UCSR0B=__ws2812b_initialized;
  UBRR0 =0;
}

/* A = {r2:r3}    B = {r4:r5}    C = {r6,r7} */
/*                                           */
/* X --> A                                   */
/* Z --> B --> X                             */
/*       C --> Z                             */
/* SREG->Clo                                 */
/*       Chi as tmp                          */
ISR(WS2812B_REFILLISR_vect, ISR_NAKED) {
    asm volatile (
        /* backup registers */
        "movw	r2      ,		r26                     \n\t" /* movw A  , X       --> 1 */
        "movw	r26     ,	    r4                      \n\t" /* movw X  , B       --> 1 */
        "movw	r4      ,   	r30                     \n\t" /* movw B  , Z       --> 1 */
        "movw	r30     ,   	r6                      \n\t" /* movw Z  , C       --> 1 */
        "in     r6      ,   	%[sreg]      	        \n\t" /* in   Clo, SREG    --> 1 */

        "cpi    r31     ,       hi8(%[nrziend])         \n\t" /* cpi  Zhi, const+3 --> 1 */
        "breq   __ws2812b_refillvect_nextByte%=         \n\t" /* breq @nextPixel   --> 1 */

        /* load next nrzi sequence to send to spi */
        "lpm    r7      ,       Z                       \n\t" /* lpm r7, Z         --> 3 */
        "sts    %[spidr],       r7                      \n\t" /* sts SPIDR, r7     --> 2 */
        "inc    r31                                     \n\t" /* inc Zhi           --> 1 */
"__ws2812b_refillvect_alternaterestore%=:               \n\t"
        /* restore for leaving interrupt */
        "out    %[sreg] ,       r6                      \n\t" /* out SREG, Clo     --> 1 */
        "movw   r6      ,       r30                     \n\t" /* movw C, Z         --> 1 */
        "movw   r30     ,       r4                      \n\t" /* movw Z, B         --> 1 */
        "movw   r4      ,       r26                     \n\t" /* movw B, X         --> 1 */
        "movw   r26     ,       r2                      \n\t" /* movw X, A         --> 1 */
        "reti                                           \n\t"


"__ws2812b_refillvect_nextByte%=:                       \n\t" /*                   --> 1 */
        "ldi    r31     ,       hi8(%[nrziptr])         \n\t" /* ldi Zhi, static   --> 1 */
        "ld     r30     ,       X+                      \n\t" /* ldd Zlo, X+       --> 2 */
        
        /* load next nrzi sequence to send to spi */
        "lpm    r7      ,       Z                       \n\t" /* lpm r7, Z         --> 3 */
        "sts    %[spidr],       r7                      \n\t" /* sts SPIDR, r7     --> 2 */
        "inc    r31                                     \n\t" /* inc Zhi           --> 1 */
        /* check for eof sequence */
        "cp     r26     ,       r8                      \n\t" /* cp  Xlo, Dlo      --> 1 */
        "cpc    r27     ,       r9                      \n\t" /* cpc Xhi, Dhi      --> 1 */
        "breq   __ws2812b_refillvect_finishTX%=         \n\t" /* breq @finishTX    --> 1 */
"__ws2812b_refillvect_finalrestore%=:                   \n\t"
        /* restore for leaving interrupt */
        "out    %[sreg] ,       r6                      \n\t" /* out SREG, Clo     --> 1 */
        "movw   r6      ,       r30                     \n\t" /* movw C, Z         --> 1 */
        "movw   r30     ,       r4                      \n\t" /* movw Z, B         --> 1 */
        "movw   r4      ,       r26                     \n\t" /* movw B, X         --> 1 */
        "movw   r26     ,       r2                      \n\t" /* movw X, A         --> 1 */
        "reti                                           \n\t"


"__ws2812b_refillvect_finishTX%=:                       \n\t" /*                   --> 1 */
        /* here we can take our time to disable UDRIE0 */
        "lds    r26     ,       %[ucsrb]                \n\t"
        "andi   r26     ,       %[udriemsk]             \n\t"
        "sts    %[ucsrb],       r26                     \n\t"
        "rjmp   __ws2812b_refillvect_finalrestore%=     \n\t"
        : /* output */
        : [sreg]	 "i"	(_SFR_IO_ADDR(SREG)),
          [spidr]    "i"	(_SFR_MEM_ADDR(UDR0)),
          [ucsrb]    "i"	(_SFR_MEM_ADDR(UCSR0B)),
          [udriemsk] "i"    ((~(_BV(UDRIE0))) & 0xff),
          [nrziptr]	 "i"	((&__NRZIsequence[0][0])),
          [nrziend]	 "i"	((&__NRZIsequence[3][0])) /* fully intentionally out of bound - it signals the end of the __NRZIsequence */
    );
}

EXTFUNC(int8_t, ws2812b_txbuffer, const void* buffer, size_t bufferbytesize) {
    if (bufferbytesize > 0) {
        if (ws2812b_inTX()) return -1;
        asm volatile (
        /* calculate ending pointer */
        "push   r26                                     \n\t"
        "push   r27                                     \n\t"
        "push   r30                                     \n\t"
        "push   r31                                     \n\t"
        "movw	r8      ,   	r26                     \n\t"
        "add    r8      ,       %A[siz]                 \n\t"
        "adc    r9      ,       %B[siz]                 \n\t"

        /* load first value */
        "ld     r30     ,       X+                      \n\t"
        "lpm                                            \n\t"
        "inc    r31                                     \n\t"
        "movw	r4      ,   	r26                     \n\t"
        "movw	r6      ,   	r30                     \n\t"

        /* enable UDRIE0 */
        "lds    r26     ,       %[ucsrb]                \n\t"
        "ori    r26     ,       %[udriemsk]             \n\t"
        "sts    %[ucsrb],       r26                     \n\t"

        /* enable correct baudrate */
        "sts    %[ubrrl],       %[rate]                 \n\t"
       
        /* first fill */
        "sts    %[spidr],       r0                      \n\t"

        /* probably here the WS2812B_REFILLISR_vect will fire */
        "pop    r31                                     \n\t"
        "pop    r30                                     \n\t"
        "pop    r27                                     \n\t"
        "pop    r26                                     \n\t"
        : /* output */
        : [spidr]    "i"	(_SFR_MEM_ADDR(UDR0)),
          [ucsrb]    "i"	(_SFR_MEM_ADDR(UCSR0B)),
          [ubrrl]    "i"	(_SFR_MEM_ADDR(UBRR0L)),
          [udriemsk] "i"    ((_BV(UDRIE0)|_BV(TXEN0)|_BV(TXCIE0)) & 0xff),
          [nrziptr]	 "z"	((&__NRZIsequence[0][0])),
          [buf]	     "x"	(buffer),
          [siz]      "r"    (bufferbytesize),
          [rate]     "r"    (__ws2812b_baudrateval)  
        : "r0"
        );
        return 0;
    }
    return -2;
}
